# 検索パフォーマンス設計

## 作成日時
2025-11-24

## 概要
記事検索機能におけるインデックス利用とパフォーマンス特性について、実装前に検討した内容をまとめる。

---

## インデックス構成

### articlesテーブルのインデックス

| インデックス名 | カラム | 種類 | 用途 |
|--------------|--------|------|------|
| PRIMARY | id | PRIMARY KEY | 主キー |
| idx_url (UNIQUE) | url | UNIQUE INDEX | URL完全一致検索 |
| idx_published_at | published_at | INDEX | 日付範囲検索・ソート |
| idx_title | title | FULLTEXT | タイトル部分一致検索 |
| idx_created_at | created_at | INDEX | 古いデータ削除 |

---

## 検索パターン別のインデックス利用状況

### パターン1: URL検索（完全一致）

**クエリ例**:
```php
Article::byUrl('https://example.com/article/123')->first();
```

**生成SQL**:
```sql
SELECT * FROM articles WHERE url = 'https://example.com/article/123' LIMIT 1;
```

**インデックス利用**: ✅ `idx_url` (UNIQUE INDEX)  
**パフォーマンス**: 超高速（主キー検索相当）  
**100万件での予測**: < 0.01秒

---

### パターン2: 日付範囲検索のみ

**クエリ例**:
```php
Article::publishedFrom('2025/11/01')
    ->publishedTo('2025/11/30')
    ->newest()
    ->paginate(20);
```

**生成SQL**:
```sql
SELECT * FROM articles 
WHERE published_at >= '2025/11/01 00:00:00'
  AND published_at <= '2025/11/30 23:59:59'
ORDER BY published_at DESC
LIMIT 20;
```

**インデックス利用**: ✅ `idx_published_at`  
**効率**:
- WHERE句: インデックス範囲スキャン
- ORDER BY: インデックス順序利用（ソート不要）

**パフォーマンス**: 高速  
**100万件での予測**: < 0.1秒

---

### パターン3: タイトル検索のみ

**クエリ例**:
```php
Article::byTitle('Laravel')->newest()->paginate(20);
```

**生成SQL**:
```sql
SELECT * FROM articles 
WHERE MATCH(title) AGAINST('Laravel' IN BOOLEAN MODE)
ORDER BY published_at DESC
LIMIT 20;
```

**インデックス利用**: ✅ `idx_title` (FULLTEXT)  
**効率**:
- WHERE句: FULLTEXT検索（高速）
- ORDER BY: 結果セットをソート（**インデックス未使用**）

**パフォーマンス**: 高速（結果が数百〜数千件に絞り込まれる場合）  
**100万件での予測**: 0.1〜1秒（キーワード次第）

---

### パターン4: タイトル + 日付範囲（複合条件）⚠️

**クエリ例**:
```php
Article::byTitle('Laravel')
    ->publishedFrom('2025/11/01')
    ->publishedTo('2025/11/30')
    ->newest()
    ->paginate(20);
```

**生成SQL**:
```sql
SELECT * FROM articles 
WHERE MATCH(title) AGAINST('Laravel' IN BOOLEAN MODE)
  AND published_at >= '2025/11/01 00:00:00'
  AND published_at <= '2025/11/30 23:59:59'
ORDER BY published_at DESC
LIMIT 20;
```

**インデックス利用**: ⚠️ **FULLTEXTインデックスのみ**

**実際の処理フロー**:
1. ✅ `idx_title` でFULLTEXT検索 → N件取得
2. ❌ N件に対して `published_at` 範囲チェック（**インデックス未使用**）
3. ❌ 残った結果をメモリ上でソート（**インデックス未使用**）
4. 20件を返却

**重要**: MySQLは通常1つのクエリで1つのインデックスしか使えない

**パフォーマンス特性**:

| FULLTEXTの結果件数 | パフォーマンス | 理由 |
|------------------|--------------|------|
| 100件以下 | 高速 | 後続処理のコストが小さい |
| 数百〜数千件 | 普通 | フィルタとソートに時間がかかる |
| 数万件以上 | **遅い** | 大量データのフィルタ・ソート |

**キーワードによる影響**:
- ✅ 固有名詞（「ウクライナ」「OpenAI」）: 結果が絞り込まれる → 高速
- ⚠️ 汎用語（「政府」「経済」「日本」）: 大量ヒット → 遅い

---

## パフォーマンス改善案

### 案1: 現状維持（推奨）

**理由**:
- ニュース記事のタイトル検索は固有名詞が多く、十分絞り込まれる想定
- ページネーション（20件/ページ）で結果セットは小さい
- 実装がシンプルで保守性が高い

**リスク**:
- 汎用的なキーワードでは遅延の可能性

**対策**:
- 本番データでパフォーマンステスト実施
- スロークエリログで問題箇所を特定

---

### 案2: 検索戦略の分岐（Service層で実装）

**実装例**:
```php
// app/Services/ArticleSearchService.php
public function search(array $params): LengthAwarePaginator
{
    $query = Article::query();
    
    if (!empty($params['title'])) {
        // タイトル検索がある → FULLTEXTに任せる
        $query->byTitle($params['title'])
              ->publishedFrom($params['date_from'])
              ->publishedTo($params['date_to']);
    } else {
        // タイトル検索がない → 日付インデックスを最大活用
        $query->publishedFrom($params['date_from'])
              ->publishedTo($params['date_to']);
    }
    
    if (!empty($params['url'])) {
        $query->byUrl($params['url']);
    }
    
    return $query->newest()->paginate(20);
}
```

**メリット**:
- 検索パターンごとに最適なインデックスを利用
- Model層はシンプルに保てる

**デメリット**:
- Service層のロジックが複雑化

---

### 案3: 複合インデックスの追加

**追加するインデックス**:
```php
// マイグレーション
$table->index(['published_at', 'created_at'], 'idx_published_created');
```

**効果**:
- 日付範囲検索のパフォーマンス向上
- ただし、**FULLTEXTとは併用できない**

**結論**: タイトル検索との複合条件では効果なし

---

### 案4: 検索エンジンの採用（将来的な選択肢）

**候補**:
- Meilisearch（軽量、Laravelと相性良い）
- Elasticsearch（高機能だが重い）
- Algolia（SaaS、有料）

**メリット**:
- 複数条件の高速検索
- ファセット検索、オートコンプリートなど高度な機能
- スコアリングによる関連度順ソート

**デメリット**:
- インフラの複雑化
- 運用コストの増加
- このプロジェクトには過剰

**導入判断基準**:
- データ量が100万件を超える
- 複合検索のパフォーマンス問題が顕在化
- より高度な検索機能が必要になった場合

---

## 実装時のチェックリスト

検索機能を実装する際は、以下を確認すること：

### 1. パフォーマンステスト

```bash
# 大量ダミーデータ作成
php artisan db:seed --class=ArticleSeeder # 100万件生成

# スロークエリログ有効化（my.cnf）
slow_query_log = 1
long_query_time = 1
```

### 2. EXPLAINで実行計画確認

```sql
EXPLAIN SELECT * FROM articles 
WHERE MATCH(title) AGAINST('keyword' IN BOOLEAN MODE)
  AND published_at >= '2025/01/01'
ORDER BY published_at DESC
LIMIT 20;
```

**確認ポイント**:
- `type`: `fulltext` になっているか
- `key`: 使用されているインデックス名
- `rows`: スキャン行数（少ないほど良い）

### 3. 実測値の記録

| 検索条件 | データ件数 | 実行時間 | 備考 |
|---------|-----------|---------|------|
| タイトルのみ | 100万件 | ?秒 | |
| 日付範囲のみ | 100万件 | ?秒 | |
| タイトル+日付 | 100万件 | ?秒 | |

---

## 参考資料

- [MySQL FULLTEXT Index](https://dev.mysql.com/doc/refman/8.0/en/fulltext-search.html)
- [Laravel クエリビルダー](https://laravel.com/docs/10.x/queries)
- [MySQLのインデックス設計](https://dev.mysql.com/doc/refman/8.0/en/optimization-indexes.html)

---

## 更新履歴

| 日付 | 内容 |
|------|------|
| 2025-11-24 | 初版作成 |

