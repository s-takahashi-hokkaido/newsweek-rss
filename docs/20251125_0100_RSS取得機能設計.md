# RSS取得機能 設計書

## 作成日時
2025-11-25 01:00

## 概要
ニューズウィーク日本版のRSSフィードから記事を取得し、データベースに保存する機能の詳細設計。

---

## 設計方針の決定事項

### 1. 重複記事の扱い
**採用: firstOrCreate方式**

```php
Article::firstOrCreate(
    ['url' => $item['url']], // 検索条件
    $item                     // 作成データ
);
```

**理由:**
- ニュース記事は公開後に変更されることは稀
- 5分ごとに不要なUPDATEクエリが走るのを防ぐ
- パフォーマンス最適化（100万件想定）
- `updated_at` が本来の意味を保持

**代替案として検討したもの:**
- ❌ `updateOrCreate`: 毎回UPDATEが走り、パフォーマンス悪化
- ❌ try-catch方式: 例外処理のオーバーヘッド
- ❌ 事前存在チェック: N+1的なSELECTクエリ増加

---

### 2. 取得件数が0件の場合
**採用: 成功として扱う**

```php
// RssFetchLog
[
    'status' => 'success',
    'articles_count' => 0,
    'error_message' => null
]

// コンソール出力
"RSS取得完了: 0件の新規記事を保存しました"
```

**理由:**
- RSS取得自体は成功している
- 全て既存記事で新規記事がないのは正常な状態
- エラーとして扱うと誤ったアラートが発生

---

### 3. エラー時のリトライ機能
**採用: シンプルなリトライ実装（3回、2秒間隔）**

```php
$maxRetries = config('rss.retry_count', 3);
$retryDelay = config('rss.retry_delay', 2);

for ($attempt = 1; $attempt <= $maxRetries; $attempt++) {
    try {
        $response = $client->get($url);
        break; // 成功したらループを抜ける
    } catch (\GuzzleHttp\Exception\RequestException $e) {
        if ($attempt === $maxRetries) {
            throw $e; // 最終試行で失敗したら例外スロー
        }
        Log::warning("RSS取得リトライ", ['attempt' => $attempt, 'error' => $e->getMessage()]);
        sleep($retryDelay);
    }
}
```

**理由:**
- 一時的なネットワークエラーに対応
- 実装がシンプルで理解しやすい
- 機能自体がシンプルなため、高度なリトライ機能は不要

---

### 4. 設定の外部化
**採用: config/rss.php を作成**

```php
// config/rss.php
return [
    'url' => env('RSS_FEED_URL', 'https://www.newsweekjapan.jp/story/rss.xml'),
    'user_agent' => env('RSS_USER_AGENT', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'),
    'timeout' => env('RSS_TIMEOUT', 30),
    'retry_count' => env('RSS_RETRY_COUNT', 3),
    'retry_delay' => env('RSS_RETRY_DELAY', 2),
];
```

**環境変数（.env）:**
```env
RSS_FEED_URL=https://www.newsweekjapan.jp/story/rss.xml
RSS_USER_AGENT="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
RSS_TIMEOUT=30
RSS_RETRY_COUNT=3
RSS_RETRY_DELAY=2
```

**理由:**
- 環境ごとに設定を変更可能
- テスト時にモックURLに変更可能
- Laravelの標準的な設計パターン

---

### 5. ログ出力の詳細度
**採用: 必要最小限のログ出力**

```php
// 成功時
Log::info('RSS取得成功', [
    'saved_count' => $savedCount,
    'skipped_count' => $skippedCount,
    'duration' => $duration,
]);

// 失敗時
Log::error('RSS取得失敗', [
    'error' => $e->getMessage(),
    'trace' => $e->getTraceAsString(),
]);

// リトライ時（警告レベル）
Log::warning('RSS取得リトライ', [
    'attempt' => $attempt,
    'error' => $e->getMessage(),
]);
```

**理由:**
- 本番環境でのログ肥大化を防ぐ
- 問題発生時に必要な情報は記録
- 必要に応じてコマンドの `-v` オプションで詳細出力（将来拡張）

---

### 6. タイムアウト設定
**採用: 30秒（設定ファイルで変更可能）**

```php
$client = new \GuzzleHttp\Client([
    'timeout' => config('rss.timeout', 30),
    'headers' => [
        'User-Agent' => config('rss.user_agent'),
    ],
]);
```

**理由:**
- 通常のRSS取得には十分な時間
- 大きなフィードでもタイムアウトしにくい
- 障害時も30秒で諦めるため、長時間ハングしない

---

## クラス設計

### RssFeedService

**責務:**
- RSSフィードの取得
- XMLのパース
- データベースへの保存
- エラーハンドリング

**公開メソッド:**

```php
/**
 * RSSフィードを取得して記事を保存
 *
 * @return array{success: bool, count: int, error: string|null}
 * @throws \Exception
 */
public function fetch(): array
```

**戻り値の形式:**
```php
// 成功時
[
    'success' => true,
    'count' => 15,        // 保存した新規記事数
    'error' => null
]

// 失敗時
[
    'success' => false,
    'count' => 0,
    'error' => 'HTTPリクエストタイムアウト'
]
```

**処理フロー:**

```
1. HTTPクライアント作成（User-Agent設定）
2. RSSフィードをGETリクエスト（リトライ機能付き）
3. レスポンスボディをXMLとしてパース
4. 各記事要素（<item>）をループ処理
   a. タグからデータ抽出（title, link, description, pubDate）
   b. pubDateを日付変換（RFC2822 → MySQL DATETIME）
   c. firstOrCreateでデータベース保存
   d. 新規作成された場合はカウント+1
5. 結果を返却（成功/失敗、件数）
```

---

### FetchRssCommand

**責務:**
- RssFeedServiceを呼び出す
- 実行結果をRssFetchLogに記録
- コンソールに結果を出力

**コマンド名:**
```bash
php artisan rss:fetch
```

**処理フロー:**

```
1. 開始メッセージ出力
2. 開始時刻を記録
3. RssFeedService::fetch() 呼び出し
4. 結果に基づいてRssFetchLogを作成
   - fetched_at: now()
   - status: success / failure
   - articles_count: 保存件数
   - error_message: エラーメッセージ（失敗時のみ）
5. 結果をコンソールに出力
6. 終了（成功時: exit 0、失敗時: exit 1）
```

**コンソール出力例:**

```bash
# 成功時
RSS取得を開始します...
RSS取得完了: 15件の新規記事を保存しました

# 成功（0件）
RSS取得を開始します...
RSS取得完了: 0件の新規記事を保存しました

# 失敗時
RSS取得を開始します...
RSS取得失敗: HTTPリクエストタイムアウト
```

---

## データ構造

### RSS XMLの構造

```xml
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>ニューズウィーク日本版</title>
    <link>https://www.newsweekjapan.jp/</link>
    <description>...</description>
    
    <item>
      <title>記事タイトル</title>
      <link>https://www.newsweekjapan.jp/stories/world/2025/11/post-123456.php</link>
      <guid>https://www.newsweekjapan.jp/stories/world/2025/11/post-123456.php</guid>
      <description><![CDATA[記事の内容や要約]]></description>
      <pubDate>Mon, 25 Nov 2025 10:30:00 +0900</pubDate>
    </item>
    
    <!-- 以下、複数のitem要素 -->
  </channel>
</rss>
```

### データベースへのマッピング

| articlesカラム | RSSタグ | 変換処理 |
|---------------|---------|---------|
| url | `<link>` | そのまま |
| title | `<title>` | そのまま |
| content | `<description>` | CDATA部分を抽出 |
| published_at | `<pubDate>` | RFC2822 → Y-m-d H:i:s |

### 日付変換の実装

```php
use Carbon\Carbon;

// 入力: "Mon, 25 Nov 2025 10:30:00 +0900"
// 出力: "2025-11-25 10:30:00"

$pubDate = (string) $item->pubDate;
$publishedAt = Carbon::createFromFormat('D, d M Y H:i:s O', $pubDate)
    ->format('Y-m-d H:i:s');
```

**エラーハンドリング:**
- フォーマットが不正な場合は例外が発生
- その記事はスキップしてログに記録
- 処理は継続（他の記事は保存する）

---

## エラーハンドリング

### 想定エラーと対応

| エラー種別 | 原因 | 対応 |
|-----------|------|------|
| HTTPリクエスト失敗 | 接続エラー、タイムアウト | リトライ（3回） → 失敗ログ記録 |
| XML形式不正 | HTMLが返却、破損データ | エラーログ記録 → 失敗ステータス |
| 日付フォーマット不正 | pubDateの形式が異常 | その記事をスキップ、警告ログ |
| データベースエラー | 接続失敗、制約違反 | エラーログ記録 → 失敗ステータス |
| User-Agent未設定 | 設定ミス | HTMLが返却 → XML形式不正として検知 |

### エラー時の挙動

**部分失敗の許容:**
- 10件中1件がエラー → 9件は保存して成功扱い
- ただし警告ログに記録

**全体失敗:**
- HTTPリクエスト失敗、XMLパース失敗など
- RssFetchLogに `failure` ステータスで記録
- コマンドは exit 1 で終了

---

## パフォーマンス考慮

### 想定データ量

- RSS内の記事数: 50件程度
- 5分ごとに実行
- 新規記事: 0〜20件程度
- 既存記事: 30〜50件程度

### クエリ数の試算

**firstOrCreateの場合:**
```
新規記事15件: SELECT(15回) + INSERT(15回) = 30クエリ
既存記事35件: SELECT(35回) = 35クエリ
合計: 65クエリ
```

**最適化の余地:**
- 必要であれば一括存在チェック → 一括INSERT
- ただし現状のデータ量では不要（50件程度）
- 100万件はarticlesテーブルの蓄積データであり、RSS内の件数ではない

### データベース負荷

- 5分に1回の実行
- 1回あたり約65クエリ
- 十分に軽い処理

---

## テスト方針

### ユニットテスト: RssFeedServiceTest

**テストケース:**

1. **正常系: RSS取得と保存**
   - モックHTTPレスポンスで正常なXMLを返す
   - 記事が正しくパースされる
   - データベースに保存される
   - 保存件数が正しい

2. **正常系: 重複記事のスキップ**
   - 既存記事と同じURLが含まれる
   - 新規記事のみ保存される
   - 既存記事は更新されない

3. **正常系: 日付変換**
   - RFC2822形式の日付が正しく変換される
   - タイムゾーンが考慮される

4. **異常系: HTTPリクエスト失敗**
   - 接続エラーをシミュレート
   - リトライが実行される
   - 最終的に失敗ステータスを返す

5. **異常系: XML形式不正**
   - HTMLレスポンスをシミュレート
   - XML解析エラーが発生
   - 失敗ステータスを返す

6. **異常系: 日付フォーマット不正**
   - 不正な日付形式を含むXML
   - その記事はスキップされる
   - 他の記事は保存される

7. **境界値: 0件の記事**
   - 空のRSSフィード
   - 成功ステータス、0件として記録

### フィーチャーテスト: FetchRssCommandTest

**テストケース:**

1. **コマンド実行成功**
   - コマンドが正常に実行される
   - exit code 0
   - RssFetchLogに成功ログが記録される

2. **コマンド実行失敗**
   - サービスが例外をスロー
   - exit code 1
   - RssFetchLogに失敗ログが記録される

3. **コンソール出力確認**
   - 成功時のメッセージが表示される
   - 件数が正しく表示される

### モック戦略

**HTTPクライアントのモック:**
```php
// Guzzle HTTPクライアントをモック
$mock = new \GuzzleHttp\Handler\MockHandler([
    new \GuzzleHttp\Psr7\Response(200, [], $xmlContent),
]);
$handlerStack = \GuzzleHttp\HandlerStack::create($mock);
$client = new \GuzzleHttp\Client(['handler' => $handlerStack]);
```

**テスト用RSS XML:**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <item>
      <title>テスト記事1</title>
      <link>https://example.com/article/1</link>
      <description>テスト内容1</description>
      <pubDate>Mon, 25 Nov 2025 10:00:00 +0900</pubDate>
    </item>
    <item>
      <title>テスト記事2</title>
      <link>https://example.com/article/2</link>
      <description>テスト内容2</description>
      <pubDate>Mon, 25 Nov 2025 11:00:00 +0900</pubDate>
    </item>
  </channel>
</rss>
```

---

## 実装チェックリスト

### 準備
- [x] 設計ドキュメント作成
- [x] config/rss.php 作成
- [x] .env.example に環境変数追加
- [x] .env に環境変数追加

### 実装
- [x] app/Services/RssFeedService.php 作成
  - [x] HTTPクライアント初期化
  - [x] RSS取得（リトライ機能付き）
  - [x] XMLパース
  - [x] 日付変換
  - [x] データベース保存（firstOrCreate）
  - [x] エラーハンドリング
- [x] app/Console/Commands/FetchRssCommand.php 作成
  - [x] サービス呼び出し
  - [x] ログ記録
  - [x] コンソール出力

### テスト
- [x] tests/Unit/Services/RssFeedServiceTest.php 作成
  - [x] 正常系テスト（日付変換、必須項目チェック）
  - [x] 異常系テスト（不正日付、不正XML、空RSS）
  - [x] 境界値テスト（必須項目不足）
  - [注] HTTPモック化テストは2件スキップ（リファクタリング要）
- [x] tests/Feature/Console/Commands/FetchRssCommandTest.php 作成
  - [x] コマンド実行テスト（成功・失敗・0件）
  - [x] ログ記録テスト
  - [x] 複数実行テスト

### 動作確認
- [x] 手動実行テスト
  ```bash
  php artisan rss:fetch
  # 結果: 12件の記事を取得・保存
  ```
- [x] データ確認
  ```bash
  php artisan tinker
  > Article::count()  // 12
  > Article::latest('published_at')->first()
  > RssFetchLog::latest()->first()  // success
  ```
- [x] テスト実行
  ```bash
  php artisan test
  # 結果: 26 passed, 2 skipped
  ```

---

## 参考情報

### 関連ドキュメント
- `REQUIREMENTS.md` - 課題要件
- `CLAUDE.md` - 実装ルール
- `docs/20251123_2243_データベース仕様書.md` - DB設計
- `docs/20251124_1400_今後の実装タスク一覧.md` - タスク一覧

### 重要な技術情報

**User-Agent必須:**
```bash
# ❌ 失敗（HTMLが返る）
curl "https://www.newsweekjapan.jp/story/rss.xml"

# ✅ 成功（XMLが返る）
curl -A "Mozilla/5.0..." "https://www.newsweekjapan.jp/story/rss.xml"
```

**日付フォーマット:**
- 入力: `D, d M Y H:i:s O` (RFC2822)
- 出力: `Y-m-d H:i:s` (MySQL DATETIME)
- Carbon::createFromFormat() を使用

---

## 更新履歴

| 日付 | 内容 |
|------|------|
| 2025-11-25 01:00 | 初版作成（設計確定） |
| 2025-11-25 11:00 | 実装完了・テスト完了（26 passed, 2 skipped） |


